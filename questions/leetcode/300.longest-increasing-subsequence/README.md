# 300.最长递增子序列

<https://leetcode-cn.com/problems/longest-increasing-subsequence/description/>

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

示例 1：

```text
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

示例 2：

```text
输入：nums = [0,1,0,3,2,3]
输出：4
```

示例 3：

```text
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

提示：

- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`

**进阶：**

- 你可以设计时间复杂度为 $O(n^2)$ 的解决方案吗？
- 你能将算法的时间复杂度降低到 $O(nlog_2_n)$ 吗?

## 总结

条件

- 【TODO】

分析

- 【TODO】

### 动态规划

分析

- 【TODO】

实现

```rust
fn length_of_lis(nums: Vec<i32>) -> i32 {
    let mut count = 0usize;
    let mut dp = vec![0usize; nums.len()];
    for i in 0..nums.len() {
        for j in 0..i {
            if nums[i] > nums[j] && dp[i] < dp[j] {
                dp[i] = dp[j];
            }
        }
        dp[i] += 1;
        if dp[i] > count {
            count = dp[i];
        }
    }
    count as i32
}
```

复杂度

- 时间：$O(n^2)$
- 空间：O(n)

### 贪心法+二分搜索

分析

- 【TODO】

  动规复杂度之所以高是因为每遍历一个元素都要向前检查所有元素的状态(即以前面某元素为序列尾的长度), 这个时候当前元素与前面某元素的关系只有当前元素更大或更小:

  - 对于所有比当前元素更小的前序尾元素: 我们只是需要这些元素里面序列最长的那个尾元素
  - 对于所有比当前元素更大的前序尾元素: 如果当前元素还比其所属序列其他元素大, 就以当前元素代替这些前序尾元素作为序列的新尾部, 从而得到更多变长机会; 对于某一个上升子序列来说, 遍历到一个新的更适合的尾元素(新元素比原来的尾元素小, 但大于序列其他元素), 意味着在序列尾元素到新元素之间的所有元素都是大于二者的, 因此把尾元素改为新元素, 不会错失序列增长的机会, 反而提高了之后扩增的概率

  换言之，我们为每个元素遍历前序尾元素时, 实际上要做的就两件事：

  - 找到尾元素比当前元素小的、最长的序列
  - 更新所有尾元素比当前元素大、且其他元素比当前元素小的序列

  利用这一点来加速前向遍历的话, 可以将动归数组改造为:

  `dp[l]`表示长度为l的上升序列的尾元素:

  - 下标即序列长度, 元素即序列尾部
  - 每个元素都是已知元素中符合该长度序列条件下的最小元素

  此时前向遍历只需要检查动归数组尾元素是否比当前元素小:

  - 当前元素大于动归数组尾元素: 将当前元素插入动归数组尾部, 即找到一个更长的序列. 因为动归数组是递增的, 不需要继续遍历了, 前面肯定没有能被更新的尾元素
  - 当前元素小于动归数组尾元素: 这次遍历没有找到一个更长的序列, 但是可以看有无更新以前某序列尾元素从而提高之后找到更长序列的机会

    向前寻找第一个小于当前元素的前序尾元素, 假设第一个小于当前元素的尾元素下标为`l`, 则将第`l+1`个前序尾元素更新为当前元素. 因为我们为长度`l`的序列找到了扩增到`l+1`的尾元素, 且这个新的尾元素比之前的长度`l+1`的序列尾元素要小, 因此替换掉原本`l+1`的尾元素

    由于被更换的动归元素是全面劣势于当前元素的, 而其他长度的动归元素没有变化, 因此下一次动归迭代时, 策略依旧是在全量信息的基础上计算的.

- 二分搜索

  因为`dp`是严格递增的, 所以可以使用二分搜索加速前向遍历

实现

```rust
fn length_of_lis(nums: Vec<i32>) -> usize {
    if nums.is_empty() {
        0
    } else {
        let mut dp = Vec::with_capacity(nums.len());
        dp.push(nums[0]);
        for i in 1..nums.len() {
            if *dp.last().unwrap() < nums[i] {
                dp.push(nums[i]);
            } else {
                let mut l = 0;
                let mut r = dp.len() - 1;
                while l + 1 < r {
                    let m = (r - l) / 2 + l;
                    if dp[m] < nums[i] {
                        l = m;
                    } else {
                        r = m - 1;
                    }
                }
                if dp[r] < nums[i] {
                    dp[r + 1] = nums[i];
                } else if dp[l] < nums[i] {
                    dp[l + 1] = nums[i];
                } else {
                    dp[0] = nums[i];
                }
            };
        }

        dp.len()
    }
}
```

复杂度

- 时间：$O(nlog_2_n)$
- 空间：O(n)
