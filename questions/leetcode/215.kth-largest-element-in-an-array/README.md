# 215.数组中的第K个最大元素

<https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/>

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

示例 1:

```txt
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

示例 2:

```txt
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

提示：

- `1 <= k <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`

## 总结

条件

- 【TODO】

### k-堆

分析

- 【TODO】
  - 维护一个只有k个元素的最小堆，遍历输入元素依次放入堆中：
    - 堆节点小于k个：直接入堆
    - 堆节点等于k个：比较堆顶和当前遍历的元素：
      - 堆顶更大：跳过当前遍历的元素出现次数
      - 堆顶更小：取出堆顶后入堆。因为当前遍历的元素比堆顶元素更大，更有资格进入top-K
  - 遍历结束后，堆顶就是要找的第k个最大元素

算法

```TODO
```

复杂度

- 时间：O(TODO)
- 空间：O(TODO)

### 快速选择

分析

- 【TODO】
  - 可以借鉴快排的维护有序区间的思想，每次选择一个元素作为有序区间的守卫元，开辟并一个比守卫元小的有序区间，然后比较有序区间的长度$l$和$k$：
    - $l=k$：找到了top-K，返回结果
    - $l<k$：在守卫元的右侧有序区间中选择一个新的守卫元，并仅对该区间数据再进行一次类似快排的步骤
    - $l>k$：在守卫元的左侧有序区间中选择一个新的守卫元，并仅对该区间数据再进行一次类似快排的步骤

算法

```TODO
```

复杂度

- 时间：O(TODO)
- 空间：O(TODO)
