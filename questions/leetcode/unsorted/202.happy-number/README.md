# 202.快乐数

<https://leetcode-cn.com/problems/happy-number/description/>

编写一个算法来判断一个数 `n` 是不是快乐数。
「快乐数」 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
- 如果这个过程 结果为 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

示例 1：

```text
输入：n = 19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```

示例 2：

```text
输入：n = 2
输出：false
```

提示：

- `1 <= n <= 2^31 - 1`

## 总结

条件

- 【TODO】

分析

- 数学分析

  一个数要么是快乐数, 在计算过程中收敛到1; 要么不是快乐数, 计算过程中始终不收敛.

  对于非快乐数, 它的计算死循环中计算出的中间数, 要么是重复出现的数, 要么是没有重复出现过的.

  计算过程中一旦出现一个重复的中间数, 意味着从上一次该中间数出现到这一次出现之间计算出来的所有中间数, 都会在这一次重复后都重复一遍, 形成一个周期. 而且此后再也不会有新的中间数出现, 只会不断重复该周期.

  因此非快乐数也有两种情况, 要么一个重复中间数都没有的非周期非快乐数, 要么就是周期重复的周期非快乐数.

  考虑非周期非快乐数, 它的中间数最终一定是向无穷大逼近的. 因为中间数是平方和且多项式内一定有个非0正整数, 所以一定是正整数, 而小于某数的正整数空间不是无限的, 而快乐数计算是死循环, 计算次数是无限的, 这导致若干次计算后, 整个空间内的数都出现过了, 接下来必然会出现重复中间数.

  综上, 对于任意正整数, 我们有:

  - 该数是"快乐数"
  - 该数是"非快乐数":
    - 该数是"周期非快乐数": 该数的快乐数计算过程中不断重复某个数字周期
    - 该数是"无穷非快乐数": 该数的快乐数计算过程中的中间数序列是无穷大的发散序列

  对于无穷非快乐数来说, 该问题是无解的, 因为没有任何适用的停机条件. 因此考察一下一个非快乐数是如何增长的, 任意数的增长幅度取决于该数各位的数值, 而一位数最大为9, 这意味着任意一个n位数的各位平方和的最大值是$n \cdot 9^2$:

  | N   | Max           | Sum  |
  | --- | ------------- | ---- |
  | 1   | 9             | 81   |
  | 2   | 99            | 162  |
  | 3   | 999           | 243  |
  | 4   | 9999          | 324  |
  | 5   | 99999         | 405  |
  | 6   | 999999        | 486  |
  | ... | ...           | ...  |
  | 13  | 9999999999999 | 1053 |
  | ... | ...           | ...  |

  从上表能直观的发现, 各位平方和的增长在3位数之后就根本追不上位数增长, 其原因是因为位数越多, 增长一位的幅度会越大, 但各位平方和的增长幅度始终被限制在$9^2=81$. 观察分析可以发现:

  - 3位以上, 13位以下的数的位平方和都是3位数, 如果再一次计算位平方和, 也不会超过3位数的位平方和的最大值243, 即无论进行多少次位平方和的计算, 结果始终是在小于243的3位数内, 而上面刚分析过, 小于某数的正整数空间是有限的, 因此不可能无限次不重复的计算, 必然会重复, 因此小于13位的数必然不可能是无穷非快乐数.
  - 13位及以上的数, 位平方和的涨幅远追不上位数增长的涨幅, 因此他们的位平方和的位数必然会打折, 而且每进行一次位平方和计算就会打折一次直到变成3位数, 然后直到某次计算出现重复. 比如13位9的位平方和结果是4位数, 而4位数的位平方和结果最多只有3位数. 因此13位及以上任意位数的数都不可能是无穷非快乐数

  综上, 无穷非快乐数根本不可能存在, 因此任意正整数只有两种情况, 且都有判别/停机条件:

  - 是“快乐数”: 某次计算得到结果1就可以停机
  - 是“周期性非快乐数”: 某次计算发现重复结果就可以停机

### 哈希

分析

- 【TODO】

  每次位平方和的计算都放入集合内, 一旦发现某次计算结果已经在集合内, 就可以判定该数是非快乐数, 否则直到计算出结果为1, 就可以判定该数是快乐数

实现

```rust
fn is_happy(n: i32) -> bool {
    let mut s = std::collections::HashSet::new();
    let mut n = n as u32;
    while n != 1 && s.insert(n) {
        n = square_sum(n);
    }
    n == 1
}
fn square_sum(mut n: u32) -> u32 {
    let mut ret = 0;
    while n > 0 {
        ret += (n % 10).pow(2);
        n /= 10;
    }
    ret
}
```

复杂度

- 时间：$O(\lg{n})$
- 空间：$O(\lg{n})$

### 快慢指针

分析

- 【TODO】

  如果把快乐数计算过程的中间结果按出现次序以链表组织起来会发现, 快乐数就是无环链表, 而非快乐数就是有环链表, 快乐数的判定变成了链表是否有环的判定, 自然可以用快慢指针来解决

实现

```TODO
```

复杂度

- 时间：$O(\lg{n})$
- 空间：O(1)

### 数学方法

分析

- 【TODO】

  我们知道13位及以上的数计算平方和的时候, 位长度会打折直到3位数, 在此不断打折的过程中, 每次计算出来的结果位数都不一样, 显然不可能有重复.

  当位数第一次打折进入3位数后, 再进行平方和计算就会出现在小于243的三位数内且再也无法回到243以上, 此时才有可能出现重复.

  换言之, 任意位长的数如果是非快乐数, 那么它的重复周期内的数都必然是小于243的三位数, 而这些周期内的数本身也是非快乐数.

  总而言之, 非快乐数一定是因为位平方和计算链中有小于243的非快乐数.

  因此我们可以提前算出243以内有哪些非快乐数并硬编码成映射表, 此后任意长度的数都可以在位平方和计算后查表来判断是否位快乐数. 编程计算可知, 243以内的非快乐数还是比较多的, 但是进一步检查这些非快乐数的循环周期会发现, 其实只有一个循环周期:

  $$
  4 \rightarrow 16 \rightarrow 37 \rightarrow 58 \rightarrow 89 \rightarrow 145 \rightarrow 42 \rightarrow 20 \rightarrow 4
  $$

  综上, 任意数本身或在计算位平方和时出现以上循环周期中数字的任一个, 都必然是非快乐数

实现

```rust
fn is_happy(n: i32) -> bool {
    let s = std::collections::HashSet::<u32>::from_iter(vec![4, 16, 20, 37, 42, 58, 89, 145]);
    let mut n = n as u32;
    while n != 1 && !s.contains(&n) {
        n = square_sum(n);
    }
    n == 1
}
fn square_sum(mut n: u32) -> u32 {
    let mut ret = 0;
    while n > 0 {
        ret += (n % 10).pow(2);
        n /= 10;
    }
    ret
}
```

复杂度

- 时间：$O(\lg{n})$
- 空间：O(1)
