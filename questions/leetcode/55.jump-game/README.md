# 55.跳跃游戏

<https://leetcode-cn.com/problems/jump-game/description/>

给定一个非负整数数组 `nums` ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

示例 1：

```txt
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

示例 2：

```txt
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

提示：

- `1 <= nums.length <= 3 * 10^4`
- `0 <= nums[i] <= 10^5`

## 总结

条件

- 【TODO】

分析

- 【TODO】

### 动态规划

分析

- 【TODO】
  - 当跳跃可以越过某个下标时，此时跳跃策略只有两种选择：
    - 直接越过该下标
    - 在该下标重新跳跃

    只有从该下标重新跳跃所能到达距离比直接越过还要短时，我们才会选择直接越过该下标，对于越过下标这个跳跃策略而言：

    - 从前一下标$i-1$越过当前下标$i$：前一下标$i-1$的最远距离等于下标对应值
    - 从比$i-1$更早的下标越过当前下标$i$：前一下标$i-1$的最远距离等于更前的下标$i-2, i-3, ...$等的最远距离，此时$i-1$的最远距离意味着$i-1$之前的某个下标起跳到达的最远距离

    当下标$i$选择被越过时，也意味着它之前的所有下标都可达，且从他之前的某个下标起跳可以比从它自身起跳更远，所以它的最远距离就是前一下标的最远距离，而前一下标的最远距离同样是要么以自身起跳、要么从更前的某个下标起跳

  - 令$DP_i$表示跳跃经过下标$i$时能跳到的最远的下标，则有如下递推方程：

    $DP_i = max\left\{\begin{array}{l}
    a_i \\
    DP_{i-1} \\
    \end{array}\right.$

  - 当某一下标的最远距离计算出来可以到达最后一个下标时就可以返回结果，或者某次遍历发现前一下标的最远距离无法到达当前下标时结束计算并返回失败的结果

实现

```TODO
```

复杂度

- 时间：O(TODO)
- 空间：O(TODO)

### 贪心法

分析

- 【直觉切入】
  - 问题解答只需要遍历所有下标，当发现某个下标起跳时能否达到最末尾就可以确定答案。而某下标是否能遍历，取决于之前某个下标起跳能否到达该下标
  - 因此设置动态变量在每次遍历时记录当前遍历到的下标起跳最远能到达哪里，并在该最远跳跃范围内继续遍历。直到最远跳跃范围无法继续更新，而范围内又没有下标能跳跃到最末尾时返回失败

- 【动态规划切入：记忆简化】
  - 动态规划的分析中，可以发现，我们需要记忆的只有前一下标的最远距离，它意味着当前下标$i$之前某个下标起跳的最远距离
  - 因此我们只需在遍历中不断的在自身起跳和之前起跳之间选择最大值，并将最大值更新到之前起跳的记忆变量中，就可以在下一次遍历继续比对并更新，直到某次遍历中发现能到达最远下标

实现

```TODO
```

复杂度

- 时间：O(TODO)
- 空间：O(TODO)
