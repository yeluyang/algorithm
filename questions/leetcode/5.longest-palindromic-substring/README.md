# 5.最长回文子串

<https://leetcode-cn.com/problems/longest-palindromic-substring/description/>

给你一个字符串`s`，找到`s`中最长的回文子串。

示例 1：

```txt
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

示例 2：

```txt
输入：s = "cbbd"
输出："bb"
```

示例 3：

```txt
输入：s = "a"
输出："a"
```

示例 4：

```txt
输入：s = "ac"
输出："a"
```

提示：

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成

## 总结

条件

- 【TODO】

分析

- 【TODO】

### 动态规划

分析

- 【TODO】
  - 回文串去掉头尾之后依旧是回文串，换言之，一个串是不是回文串取决于头尾是否相等以及去掉头尾后是不是回文串
  - 因此一个串是不是回文取决于一个更小规模的子问题的解，即可以分解为子问题
  - 综上，令$P(i,j)$表达串从i到j的子串是否为回文，$s_i$表达串的第i个字符，则转移方程为：

    $
    P(i, j) = P(i+1, j-1) \wedge (s_i == s_j)
    $

    边界条件为：

    $
    \left\{\begin{array}{l}
    P(i, i) = true \\
    P(i, i+1) = s_i == s_{i+1} \\
    \end{array}\right.
    $

  - 实现时为了避免重复计算，可以从最短长度即长度为1开始枚举回文子串，每次枚举都从首个字符开始遍历，检查以该字符开始的有指定长度的子串是否是回文

实现

```TODO
```

复杂度

- 时间：O(TODO)
- 空间：O(TODO)

### 贪心法

分析

- 可以从两个角度来分析：
  - 【TODO】从直觉角度来分析：
    - 回文串都有回文中心并从回文中心向两边对称扩展
    - 因此可以遍历串的每个字符，以每个字符为回文中心检查可以对称扩展多远
    - 注意长度奇偶不同的回文串的中心不同
  - 【TODO】从优化动态规划算法来分析：
    - 分析动态规划方法的转移方程，其状态转移链是这样的：

      $P(i,j) \leftarrow P(i+1,j-1) \leftarrow P(i+2,j-2) \leftarrow ... \leftarrow 边界情况$

      即状态转移链是单分支的，即任意状态的转移都是确定的，只有一个转移方向

    - 因此我们可以从每一种边界开始扩展到该边界能够扩展到的最终状态，这样一种边界能够扩展到的最终状态和中间状态都会被遍历计算到，当把所有可能的边界遍历完，则所有状态都被枚举并计算，也就完成了动态规划的全部计算
    - 而边界情况就是所有的单个字符或双字符，扩展方法就是以单字符或双字符为回文中心向两边检查是否对称

实现

```TODO
```

复杂度

- 时间：O(TODO)
- 空间：O(TODO)

### Manacher（马拉车）

分析

- 【TODO】
  - 就像KMP回溯算法的基本思想一样，当我们遍历某个字符作为回文中心的时候，我们对它其实并非一无所知，我们可以从之前遍历到的字符中得到关于它的信息
  - “回文臂”是回文中心到回文串头或尾的半径，则奇数回文串的长度是两倍臂长加一，偶数回文串是两倍臂长。请注意右侧回文臂内的每个字符在左侧回文臂内都有对应相等的字符，且这两个字符左右两侧紧邻的部分字符也是相等的。所以当我们从右侧回文臂选择任一个符作为回文中心时，都可以从左侧回文臂内我们曾遍历过的字符中获取历史信息
  - 具体来说就是当我们把某个字符$s_j$作为回文中心并发现回文串后，枚举回文臂内任一字符$s_i$作为回文中心时，都可以复用另一侧回文臂对应的字符$s_{2j-i}$被作为回文中心遍历时的信息即以$s_{2j-i}$为回文中心的回文臂长$L_{2j-i}$
  - 因为回文串的对称性，以$s_i$作为回文中心时，可以直接跳过两侧$L_{2j-i}$个字符，直接从$(i-L_{2j-i}-1, i+L_{2j-i}+1)$的对子开始比对。但要注意的是我们的已知信息来源于以$s_j$为中心的回文串，因此已知范围在回文臂范围内，而$s_{2j-i}$为中心的回文串是有可能有部分串不在$s_j$回文串内的，所以在计算可以跳过的字符数量时要做限制：$min(L_{2j-i}, j+L_{j}-i)$

实现

```TODO
```

复杂度

- 时间：O(TODO)
- 空间：O(TODO)
