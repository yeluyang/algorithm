# 二分查找

二分查找算法正确性证明如下：

循环不变式：目标值$T$如果存在与数组$A$中，则必然存在于区域$A[l .. r]$内

- 初始化：初始时$l=0$，$r=len(A)$，计算区域覆盖整个数组，此时循环不变式必然是成立的
- 保持：循环时，有如下操作，循环不变式依然成立：
  - $A_{mid} = T$：找到目标值，直接返回结果
  - $A_{mid} < T$：目标值不可能在中值左侧区域$[l .. mid]$内，只可能在右侧区域$[mid+1 .. r]$内，令$l = mid+1$。循环不变式依旧成立
  - $A_{mid} > T$：目标值不可能在中值右侧区域$[mid .. r]$内，只可能在左侧区域$[l .. mid-1]$内，令$r = mid-1$。循环不变式依旧成立
- 终止：$l > r$时停机，目标值不在数组内

## 二分查找最先出现

二分查找的变体，结合查找目的，每次二分查找时的三种情况中，等于目标值的情况有所不同：

- $A_{mid} = T$：找到目标值，则目标值首次出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在当前的中值位置，或者，左侧区域$[l .. mid-1]$内，因此令$r = mid-1$

即遇到等于目标值的元素也要像大于目标值那样，向左移动：

- $A_{mid} < T$：右移，令$l = mid+1$
- $A_{mid} \ge T$：左移，令$r = mid-1$

这个算法的正确性证明：

循环不变式：目标值$T$如果存在与数组$A$中，则目标值第一次出现的位置要么被记录为$I$，要么存在于区域$A[l .. r]$内

- 初始化：初始时$l=0$，$r=len(A)$，计算区域覆盖整个数组，此时循环不变式必然是成立的
- 保持：循环时，有如下操作，循环不变式依然成立：
  - $A_{mid} = T$：找到目标值，则目标值首次出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在当前的中值位置，或者，左侧区域$[l .. mid-1]$内，因此令$I = mid$，令$r = mid-1$。循环不变式依旧成立
  - $A_{mid} < T$：目标值首次出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在右侧区域$[mid+1 .. r]$内，令$l = mid+1$。循环不变式依旧成立
  - $A_{mid} > T$：目标值首次出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在左侧区域$[l .. mid-1]$内，令$r = mid-1$。循环不变式依旧成立
- 终止：$l > r$时停机：
  - $I$没有赋值：目标值不在数组内
  - $I$有赋值：$I$就是目标值首次出现位置

相关题目：

- [34.在排序数组中查找元素的第一个和最后一个位置](../questions/leetcode/34.find-first-and-last-position-of-element-in-sorted-array/README.md)
- [278.第一个错误的版本](../questions/leetcode/278.first-bad-version/README.md)

## 二分查找最后出现

二分查找的变体，结合查找目的，每次二分查找时的三种情况中，等于目标值的情况有所不同：

- $A_{mid} = T$：找到目标值，则目标值最后出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在当前的中值位置，或者，右侧区域$[mid+1 .. r]$内，因此令$l = mid+1$

即遇到等于目标值的元素也要像小于目标值那样，向右移动：

- $A_{mid} \le T$：右移，令$l = mid+1$
- $A_{mid} > T$：左移，令$r = mid-1$

这个算法的正确性证明：

循环不变式：目标值$T$如果存在与数组$A$中，则目标值第一次出现的位置要么被记录为$I$，要么存在于区域$A[l .. r]$内

- 初始化：初始时$l=0$，$r=len(A)$，计算区域覆盖整个数组，此时循环不变式必然是成立的
- 保持：循环时，有如下操作，循环不变式依然成立：
  - $A_{mid} = T$：找到目标值，则目标值最后出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在当前的中值位置，或者，右侧区域$[mid+1 .. r]$内，因此令$I = mid$，令$r = mid-1$。循环不变式依旧成立
  - $A_{mid} < T$：目标值最后出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在右侧区域$[mid+1 .. r]$内，令$l = mid+1$。循环不变式依旧成立
  - $A_{mid} > T$：目标值最后出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在左侧区域$[l .. mid-1]$内，令$r = mid-1$。循环不变式依旧成立
- 终止：$l > r$时停机：
  - $I$没有赋值：目标值不在数组内
  - $I$有赋值：$I$就是目标值最后出现位置

相关题目：

- [34.在排序数组中查找元素的第一个和最后一个位置](../questions/leetcode/34.find-first-and-last-position-of-element-in-sorted-array/README.md)

## 二分查找最大小值

二分搜索找出小于目标值的最大值元素, 该元素称之为“最大小值”, 比如: 在(1,2,5,6)里面, 4的最大小值是2.

二分搜索分析如下, 分析二分中值$a_m$与目标值$k$的关系以及左边界$l$和右边界$r$的变化($m = \lfloor\frac{r - l}{2}\rfloor + l$):

- $a_m < k$:
  - 范围收缩: $l = m$. 搜索范围可以缩小到$[m, r]$, 即令$l = m$, 因为最大小值要么就是$a_m$, 要么在$a_m$后面出现, 因此不仅要向后搜索, 还要将$m$也纳入后续搜索范围
  - 停机条件: $l + 1 < r$. 该情况下的收缩范围长度$L$为$L = m - l = \lfloor\frac{r - l}{2}\rfloor$, 当$l$取最大值即$l = m$时, 收缩范围是0 这会导致无法停机, 要让$L \ge 1$就必有$r - l \ge 2$, 在整数域内等价于有$l + 1 < r$
- $a_m = k$:
  - 范围收缩: $r = m - 1$. 搜索范围可以缩小到$[l, m - 1]$, 即令$r = m - 1$, 因为$a_m$是目标值, 意味着最大小值一定在$a_m$前面出现, 因此要向前搜索, 且不能把$m$纳入后续搜索范围
  - 停机条件: $l < r$. 该情况下的收缩范围长度至少为1, 因为$r$取最小值$r = m$时, 按照收缩规则也至少会减少一个元素, 因此停机条件按普通二分搜索的停机条件设置即可.
- $a_m > k$:
  - 范围收缩: $r = m - 1$. 搜索范围可以缩小到$[l, m - 1]$, 即令$r = m - 1$, 因为最大小值一定在$a_m$前面出现, 因此要向前搜索
  - 停机条件: $l < r$. 该情况下的收缩范围长度至少为1, 因为$r$取最小值$r = m$时, 按照收缩规则也至少会减少一个元素, 因此停机条件按普通二分搜索的停机条件设置即可.

当搜索停机时, 总是从大于等于3的搜索范围收缩而来, 不可能有$l > r$的情况, 但可能有搜索范围长度为2或长度为3的两种状况:

- 长度为1时: 左右端相等, 检查右端即$a_r$是否为最大小值即可
- 长度为2时: 因为$a$是递增的, 所以先检查右端是否为最大小值, 然后再检查左端

综上, 我们有如下的逻辑模版:

```rust
let mut l = 0;
let mut r = dp.len() - 1;
while l + 1 < r {
    let m = (r - l) / 2 + l;
    if a[m] < k {
        l = m;
    } else {
        r = m - 1;
    }
}
if a[r] < k {
    Some(r)
} else if a[l] < k {
    Some(l)
} else {
    None
}
```

相关题目:

- [300.最长递增子序列](../questions/leetcode/300.longest-increasing-subsequence/README.md)
